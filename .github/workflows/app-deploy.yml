name: Deploy Retail Store App

on:
  workflow_run:
    workflows: ["IaC - EKS Infra"] 
    types: [completed]

  workflow_dispatch:
    inputs:
      release:   { description: "v1.3.0 or 'latest'", required: true, default: "v1.3.0" }
      namespace: { description: "K8s namespace",       required: true, default: "retail" }

env:
  AWS_REGION: us-east-1               
  CLUSTER_NAME: bedrock-eks 
  ROLE_TO_ASSUME: arn:aws:iam::120217955965:role/github-oidc
  KUBECTL_VERSION: "1.29.0"

jobs:
  deploy:
    if: ${{ (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    concurrency:
      group: app-deploy-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with: 
          version: v1.29.0

      - name: Allow this runner IP to call EKS API
        shell: bash
        run: |
          set -euo pipefail
          RUNNER_IP="$(curl -s https://checkip.amazonaws.com | tr -d '\n')"
          echo "Runner IP: $RUNNER_IP"
          # fetch current CIDRs
          CURR_JSON="$(aws eks describe-cluster --region "${AWS_REGION}" --name "${CLUSTER_NAME}" --query 'cluster.resourcesVpcConfig.publicAccessCidrs' --output json)"
          # merge runner /32 if missing
          NEW_JSON="$(jq -c --arg ip "${RUNNER_IP}/32" 'if index($ip) then . else . + [$ip] end' <<< "$CURR_JSON")"
          # convert to comma-separated list for CLI
          CIDRS_CSV="$(jq -r 'join(",")' <<< "$NEW_JSON")"
          aws eks update-cluster-config \
            --region "${AWS_REGION}" \
            --name "${CLUSTER_NAME}" \
            --resources-vpc-config endpointPublicAccess=true,publicAccessCidrs=${CIDRS_CSV}


      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name "${CLUSTER_NAME}" --region "${AWS_REGION}"
          kubectl get nodes

      - name: Resolve namespace and manifest URL
        id: cfg
        shell: bash
        run: |
          # inputs only exist on workflow_dispatch; provide defaults for workflow_run
          NS="${{ github.event.inputs.namespace }}"
          REL="${{ github.event.inputs.release }}"
          [ -z "$NS" ] && NS="retail"
          [ -z "$REL" ] && REL="v1.3.0"
          if [ "$REL" = "latest" ]; then
            URL="https://github.com/aws-containers/retail-store-sample-app/releases/latest/download/kubernetes.yaml"
          else
            URL="https://github.com/aws-containers/retail-store-sample-app/releases/download/$REL/kubernetes.yaml"
          fi
          echo "namespace=$NS" >> "$GITHUB_OUTPUT"
          echo "manifest_url=$URL" >> "$GITHUB_OUTPUT"

      - name: Ensure namespace
        run: |
          kubectl get ns "${{ steps.cfg.outputs.namespace }}" || kubectl create ns "${{ steps.cfg.outputs.namespace }}"

      - name: Apply retail-store app (includes in-cluster MySQL/Postgres/DynamoDB Local/RabbitMQ/Redis)
        run: |
          kubectl apply -n "${{ steps.cfg.outputs.namespace }}" -f "${{ steps.cfg.outputs.manifest_url }}"

      - name: Wait for Deployments
        run: |
          kubectl -n "${{ steps.cfg.outputs.namespace }}" wait --for=condition=available --timeout=10m deployment --all

      - name: Wait for StatefulSets (DBs and broker)
        shell: bash
        run: |
          set -e
          for s in catalog-mysql orders-postgresql orders-rabbitmq; do
            echo "Waiting for StatefulSet/$s ..."
            kubectl -n "${{ steps.cfg.outputs.namespace }}" rollout status statefulset/$s --timeout=10m
          done

      - name: Discover UI LoadBalancer hostname/IP
        id: ui
        shell: bash
        run: |
          set -e
          for i in {1..60}; do
            host="$(kubectl -n "${{ steps.cfg.outputs.namespace }}" get svc ui -o jsonpath='{.status.loadBalancer.ingress[0].hostname}{.status.loadBalancer.ingress[0].ip}')"
            if [ -n "$host" ]; then
              echo "host=$host" >> "$GITHUB_OUTPUT"
              echo "UI: http://$host"
              exit 0
            fi
            echo "Waiting for Service/ui external hostname... ($i/60)"
            sleep 10
          done
          echo "UI LoadBalancer hostname not ready"; exit 1

      - name: Health check
        shell: bash
        run: |
          host="${{ steps.ui.outputs.host }}"
          for i in {1..30}; do
            code="$(curl -s -o /dev/null -w '%{http_code}' "http://$host/")"
            echo "Attempt $i -> HTTP $code"
            [ "$code" = "200" ] && exit 0
            sleep 10
          done
          echo "UI did not return 200 within time window"; exit 1

      - name: Summary
        run: |
          echo "## Retail Store Sample App deployed" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster**: ${CLUSTER_NAME}" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace**: ${{ steps.cfg.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "**Manifest**: ${{ steps.cfg.outputs.manifest_url }}" >> $GITHUB_STEP_SUMMARY
          echo "**UI URL**: http://${{ steps.ui.outputs.host }}" >> $GITHUB_STEP_SUMMARY